# goit-algo-hw-09

## Результати

```
--- coins [50, 25, 10, 5, 2, 1]
  Amount |     greedy (s) |         DP (s) |  coins_G | coins_DP
       3 |     0.00043881 |     0.00248268 |        2 |        2
       7 |     0.00043182 |     0.00375021 |        2 |        2
       8 |     0.00053693 |     0.00436383 |        3 |        3
       9 |     0.00042554 |     0.00478811 |        3 |        3
      10 |     0.00041387 |     0.00490209 |        1 |        1
     250 |     0.00037169 |     0.14586469 |        5 |        5
     500 |     0.00037330 |     0.34892882 |       10 |       10
    1009 |     0.00050781 |     0.76445263 |       23 |       23
    2049 |     0.00059727 |     1.62928295 |       45 |       45
    4097 |     0.00064958 |     3.28362692 |       85 |       85
--- coins [5, 4, 3, 2, 1]
  Amount |     greedy (s) |         DP (s) |  coins_G | coins_DP
       3 |     0.00034480 |     0.00209486 |        1 |        1
       7 |     0.00040996 |     0.00454967 |        2 |        2
       8 |     0.00046290 |     0.00506412 |        2 |        2
       9 |     0.00040877 |     0.00532916 |        2 |        2
      10 |     0.00033803 |     0.00597798 |        2 |        2
     250 |     0.00033977 |     0.11310113 |       50 |       50
     500 |     0.00035863 |     0.27159822 |      100 |      100
    1009 |     0.00041625 |     0.59428055 |      202 |      202
    2048 |     0.00044851 |     1.29865686 |      410 |      410
    4096 |     0.00042861 |     2.69473414 |      820 |      820
```

### Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування

#### Часова складність

-   Жадібний алгоритм (`find_coins_greedy`):

    -   Використовує жадібний підхід, щоб намагатися зменшити суму, вибираючи найбільші можливі монети спочатку.
    -   Часова складність: **O(n)**, де n — кількість різних монет. Алгоритм проходить через масив монет один раз для кожної суми.

-   Алгоритм динамічного програмування (`find_min_coins`):
    -   Використовує підхід динамічного програмування, щоб зберігати результати для попередніх сум і використовувати їх для обчислення нових.
    -   Часова складність: **O(n \* m)**, де n — кількість різних монет, а m — цільова сума. Кожна сума досягнута за допомогою всіх доступних монет.

#### Ефективність при великих сумах:

-   При великих сумах (2048 і 4096) час виконання динамічного програмування значно зростає.
-   Жадібний алгоритм залишається швидким.

#### Висновок:

При наявних вхідних даних обидва алгоритма видають однаковий результат, але жадібний алгоритм показує значно меньший час виконання, обобливо для великих сум.
