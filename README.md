# goit-algo-hw-09

## Результати

```
--- coins = [50, 25, 10, 5, 2, 1] ---
  Amount |     greedy (s) |         DP (s) |  coins_G | coins_DP
       8 |     0.00051452 |     0.00442159 |        3 |        3
      17 |     0.00051718 |     0.00850473 |        3 |        3
      39 |     0.00051787 |     0.02211731 |        4 |        4
      61 |     0.00054246 |     0.03880899 |        3 |        3
     128 |     0.00060965 |     0.07366726 |        5 |        5
     250 |     0.00037323 |     0.14467663 |        5 |        5
     500 |     0.00036974 |     0.34475420 |       10 |       10
    1008 |     0.00060734 |     0.74826941 |       23 |       23
    2049 |     0.00059135 |     1.58076813 |       45 |       45
    4096 |     0.00058883 |     3.22189167 |       85 |       85
--- coins = [1, 3, 4] ---
  Amount |     greedy (s) |         DP (s) |  coins_G | coins_DP
       8 |     0.00032211 |     0.00410102 |        8 |        2
      17 |     0.00030933 |     0.00829898 |       17 |        5
      39 |     0.00030444 |     0.01854415 |       39 |       10
      61 |     0.00029962 |     0.02819533 |       61 |       16
     128 |     0.00031701 |     0.05810680 |      128 |       32
     250 |     0.00030332 |     0.11125388 |      250 |       63
     500 |     0.00035088 |     0.27313246 |      500 |      125
    1008 |     0.00033328 |     0.60494658 |     1008 |      252
    2049 |     0.00034914 |     1.34480317 |     2049 |      513
    4096 |     0.00033363 |     2.82456294 |     4096 |     1024

```

### Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування

#### Часова складність

-   Жадібний алгоритм (`find_coins_greedy`):

    -   Використовує жадібний підхід, щоб намагатися зменшити суму, вибираючи найбільші можливі монети спочатку.
    -   Часова складність: **O(n)**, де n — кількість різних монет. Алгоритм проходить через масив монет один раз для кожної суми.

-   Алгоритм динамічного програмування (`find_min_coins`):
    -   Використовує підхід динамічного програмування, щоб зберігати результати для попередніх сум і використовувати їх для обчислення нових.
    -   Часова складність: **O(n \* m)**, де n — кількість різних монет, а m — цільова сума. Кожна сума досягнута за допомогою всіх доступних монет.

#### Ефективність при великих сумах:

-   При великих сумах (2048 і 4096) час виконання динамічного програмування значно зростає.
-   Жадібний алгоритм залишається швидким.

#### Висновок:

При наявних вхідних даних обидва алгоритма видають однаковий результат, але жадібний алгоритм показує значно меньший час виконання, обобливо для великих сум. Але якщо змінити набір вхідних даних `coins = [1, 3, 4]`, то алгоритм динамічного програмування, хоча і повільніший, забезпечує оптимальні рішення для нестандартних наборів монет
